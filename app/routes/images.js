// Generated by CoffeeScript 1.4.0
(function() {
  var TreeDatabase, fs, gm, raphael;

  TreeDatabase = require('../database').TreeDatabase;

  fs = require('fs');

  raphael = require('node-raphael');

  gm = require('gm');

  module.exports = function(app, config) {
    var treeDb, wrapError;
    console.log("Defining IMAGE routes");
    treeDb = new TreeDatabase(config);
    wrapError = function(res, callback) {
      return function(err, doc) {
        if (err) {
          console.trace('wrapError');
          return res.send("Something awful happened", 500);
        } else {
          return typeof callback === "function" ? callback(doc) : void 0;
        }
      };
    };
    app.get(/^\/img\/trees\/([a-zA-Z0-9_.-]+)\.svg$/, function(req, res) {
      var treeId;
      if (req.params != null) {
        treeId = req.params[0];
      }
      if (treeId) {
        return treeDb.findById(treeId, wrapError(res, function(treeDoc) {
          var svg;
          if (!treeDoc) {
            return res.send("Not found", 404);
          } else {
            res.writeHead(200, {
              "Content-Type": "image/svg+xml"
            });
            svg = raphael.generate(treeDoc.viewBoxWidth, treeDoc.viewBoxHeight, function(paper) {
              paper.setViewBox(0, 0, treeDoc.viewBoxWidth, treeDoc.viewBoxHeight, true);
              return paper.add(treeDoc.strokes);
            });
            return res.end(svg.replace('svg style="', 'svg style="background-color:#FEFDF8;'));
          }
        }));
      }
    });
    return app.get(/^\/img\/trees\/([a-zA-Z0-9_.-]+)\.png$/, function(req, res) {
      var treeId, width;
      if (req.params != null) {
        treeId = req.params[0];
      }
      width = Math.min(req.param('width', 250), 1000);
      if (treeId) {
        return treeDb.findById(treeId, wrapError(res, function(treeDoc) {
          var buf, pngFilename, stream, svg, svgFilename, time, _ref;
          if (!treeDoc) {
            return res.send("Not found", 404);
          } else {
            pngFilename = "" + width + ".png";
            if ((_ref = treeDoc._attachments) != null ? _ref.hasOwnProperty(pngFilename) : void 0) {
              stream = treeDb.db.getAttachment(treeDoc._id, pngFilename);
              stream.addListener('response', function(response) {
                res.headers = response.headers;
                return res.headers.status = response.statusCode;
              });
              stream.addListener('data', function(chunk) {
                return res.write(chunk, 'binary');
              });
              return stream.addListener('end', function() {
                return res.end();
              });
            } else {
              svg = raphael.generate(treeDoc.viewBoxWidth, treeDoc.viewBoxHeight, function(paper) {
                var bg;
                paper.setViewBox(0, 0, treeDoc.viewBoxWidth, treeDoc.viewBoxHeight, true);
                bg = paper.rect(0, 0, treeDoc.viewBoxWidth, treeDoc.viewBoxHeight);
                bg.attr({
                  fill: "#FEFDF8"
                });
                return paper.add(treeDoc.strokes);
              });
              buf = new Buffer(svg);
              svgFilename = (time = (new Date()).getTime()) + '.svg';
              return fs.writeFile(svgFilename, buf, function(err) {
                if (err) {
                  return console.error(err);
                } else {
                  return gm(svgFilename).scale(width, 1500).stream('png', function(err, stdout, stderr) {
                    stream = treeDb.db.saveAttachment(treeDoc, {
                      name: pngFilename,
                      contentType: 'image/png'
                    }, function(err, data) {
                      if (err) {
                        console.log(err);
                      }
                      return fs.unlink(svgFilename);
                    });
                    res.contentType('image/png');
                    stdout.pipe(stream);
                    return stdout.pipe(res);
                  });
                }
              });
            }
          }
        }));
      }
    });
  };

}).call(this);
